# src/satisfying_sims/core/rules.py

from __future__ import annotations
from typing import TYPE_CHECKING
from abc import ABC, abstractmethod
from typing import List
from dataclasses import asdict
import random
import numpy as np
from satisfying_sims.utils.random import rng
if TYPE_CHECKING:
    from .world import World

from .events import (
    BaseEvent,
    CollisionEvent,
    DestroyEvent,
    SpawnEvent,
)
from .shapes import Body, create_circle_body
from .physics import get_penetration

class Rule(ABC):
    """Base class for rules that modify the world based on events."""

    @abstractmethod
    def apply(self, world: World, events: List[BaseEvent], dt: float) -> List[BaseEvent]:
        """
        Apply rule logic to the world.

        Returns any new events generated by this rule (e.g., Spawn/Destroy).
        """
        ...

class SpawnOnCollision(Rule):
    """
    Whenever two bodies collide, spawn a new body.

    Default behavior:
      - Child inherits kind, radius, mass, color from body A.
      - Child is placed outside of both bodies, along the line of centers,
        at a distance that guarantees no overlap.
      - Child velocity is at rest in the center-of-mass frame of (A, B),
        i.e. in world coordinates it moves with v_cm.
    """

    def __init__(self, offset_margin: float = 0, vel_kick: float = 0.0):
        """
        offset_margin: extra distance to keep between the child and parents'
        surfaces, in the same units as positions/radii.
        vel_kick: additional velocity to give the spawned child, in the direction perpendicular to the line of centers.
        """
        self.offset_margin = offset_margin
        self.vel_kick = vel_kick

    def apply(self, world: World, events: List[BaseEvent], dt: float) -> List[BaseEvent]:
        new_events: List[BaseEvent] = []

        for e in events:
            if not isinstance(e, CollisionEvent):
                continue

            a = world.bodies.get(e.a_id)
            b = world.bodies.get(e.b_id)
            if a is None or b is None:
                continue

            # 1) Inherit "what kind of body is this?"
            props = self._inherit_properties(world, a, b, e)
            child_radius = props["radius"]

            # 2) Choose where to put it and how it moves
            pos, vel = self._choose_pos_velocity(world, a, b, child_radius, e)
            if pos is None:
                # Couldn't find valid placement
                continue
            # 3) Actually create the body in the world #TODO: expand to support different kinds of bodies
            child = create_circle_body(
                pos=pos,
                vel=vel,
                radius=child_radius,
                mass=props["mass"],
                color=props["color"],
            ) if props["kind"] == "circle" else None
            if child is not None:
                try:
                    world.add_body(child)
                except ValueError as ex:
                    self._raise_spawn_error(child, e, world, ex)

            # Optionally let subclasses tweak the created body
            self._postprocess_child(world, child, a, b, e)

            new_events.append(SpawnEvent(t=world.time, child_id=child.id, reason="collision_spawn"))

        return new_events

    # ---------- hooks you can easily override / customize ----------

    def _inherit_properties(self, world: World, a: Body, b: Body, e: CollisionEvent) -> dict:
        """
        Decide what properties the child should inherit.
        Default: copy from body A.
        """
        #TODO: expand to support different kinds of bodies
        return {
            "kind": getattr(a, "kind", "circle"),
            "radius": a.collider.radius,
            "mass": a.mass,
            "color": a.color,
        }

    def _choose_pos_velocity(
        self,
        world: World,
        a: Body,
        b: Body,
        child_radius: float, # TODO: should be bounding radius of child collider when I expand beyond circles
        e: CollisionEvent,
    ):
        """
        Place the child on a line perpendicular to the line of centers (B->A),
        at distance L = max(r_a, r_b) + child_radius + offset_margin from the midpoint.

        Randomly choose which side of the line to spawn on.

        Child velocity = center-of-mass velocity of (A, B).
        """
        pos_a = np.asarray(a.pos, dtype=float)
        pos_b = np.asarray(b.pos, dtype=float)

        # Direction from B to A
        delta = pos_a - pos_b
        dist = float(np.linalg.norm(delta))

        if dist < 1e-8:
            # Degenerate: centers coincide, pick arbitrary axis
            direction = np.array([1.0, 0.0], dtype=float)
        else:
            direction = delta / dist

        # Midpoint between A and B
        mid = 0.5 * (pos_a + pos_b)

        # Perpendicular unit vector to 'direction'
        # If direction = (dx, dy), a perpendicular is (-dy, dx) or (dy, -dx)
        perp = np.array([-direction[1], direction[0]], dtype=float)
        perp /= float(np.linalg.norm(perp))

        r_a = a.collider.bounding_radius() # use bounding_radius to be safe with different collider types
        r_b = b.collider.bounding_radius()
        R_max = max(r_a, r_b)

        # Distance from mid so we clear both parents:
        # ‖child_pos - mid‖ = R_max + child_radius + margin
        L = R_max + child_radius + self.offset_margin

        # Randomly choose side (+perp or -perp)
        options = np.array([-1.0, 1.0])
        sign = rng().choice(options, replace=False)
        perp *= sign
        child_pos = mid + L * perp
        if not self._valid_child_position(world, child_pos, child_radius): #TODO: make bounding_radius when expanding beyond circles
            # Try the other side
            perp *= -1.0
            child_pos = mid + L * perp
            if not self._valid_child_position(world, child_pos, child_radius):
                return None, None
        # Center-of-mass velocity
        vel_a = np.asarray(a.vel, dtype=float)
        vel_b = np.asarray(b.vel, dtype=float)
        m_a = a.mass
        m_b = b.mass
        m_tot = m_a + m_b

        if m_tot > 0.0:
            v_cm = (m_a * vel_a + m_b * vel_b) / m_tot
        else:
            v_cm = 0.5 * (vel_a + vel_b)

        child_vel = v_cm + self.vel_kick * perp
        return child_pos, child_vel

    def _valid_child_position(self, world: World, child_pos: np.ndarray, child_radius: float) -> bool:
        inbounds = world.boundary.contains(pos=child_pos, radius=child_radius)
        overlapping = False
        for b in world.bodies.values():
            penetration, _ = get_penetration(child_pos, child_radius, b.pos, b.collider.bounding_radius()) #conservative
            if penetration is not None and penetration > 0:
                overlapping = True
                break
        return inbounds and not overlapping

    def _postprocess_child(
        self,
        world: World,
        child: Body,
        a: Body,
        b: Body,
        e: CollisionEvent,
    ) -> None:
        """
        Optional hook: tweak life/state/etc of the child after creation.
        Default: do nothing.
        """
        pass
    def _raise_spawn_error(self, child, event, world, original_exc):
        """
        Build and raise a detailed debugging error message when a spawned body
        cannot be placed inside the world boundary.
        """
        # -- Event info --
        event_info = "\n".join(
            f"  {k}: {v}" for k, v in asdict(event).items()
        )

        # -- Parent bodies --
        a_id = getattr(event, "a_id", None)
        b_id = getattr(event, "b_id", None)

        body_a = world.bodies.get(a_id)
        body_b = world.bodies.get(b_id)

        if body_a is not None:
            body_a_info = "\n".join(
                f"  {k}: {v}" for k, v in asdict(body_a).items()
            )
        else:
            body_a_info = "  <missing>"

        if body_b is not None:
            body_b_info = "\n".join(
                f"  {k}: {v}" for k, v in asdict(body_b).items()
            )
        else:
            body_b_info = "  <missing>"

        # -- Child body info --
        child_info = "\n".join([
            f"  pos: {child.pos}",
            f"  vel: {child.vel}",
            f"  radius: {child.collider.bounding_radius()}",
            f"  mass: {child.mass}",
        ])

        # -- Boundary info --
        boundary = world.boundary
        boundary_info = "\n".join([
            f"  width: {boundary.width}",
            f"  height: {boundary.height}",
        ])

        # -- Build final message --
        msg = (
            "SpawnOnCollision produced an invalid child body placement.\n"
            f"Original error: {original_exc}\n\n"

            "CollisionEvent:\n"
            f"{event_info}\n\n"

            f"Body A (id={a_id}):\n{body_a_info}\n\n"
            f"Body B (id={b_id}):\n{body_b_info}\n\n"

            "Child Body:\n"
            f"{child_info}\n\n"

            "World Boundary:\n"
            f"{boundary_info}"
        )

        raise ValueError(msg) from original_exc

class LifetimeDecay(Rule):
    """Decreases body.life each frame; destroys when <= 0."""

    def __init__(self, rate: float = 1.0):
        self.rate = rate

    def apply(self, world: World, events: List[BaseEvent], dt: float) -> List[BaseEvent]:
        new_events: List[BaseEvent] = []
        to_destroy: List[int] = []

        for b in world.bodies.values():
            if b.life < float("inf"):
                b.life -= self.rate * dt
                if b.life <= 0:
                    to_destroy.append(b.id)
        for bid in to_destroy:
            world.remove_body_by_id(bid)
            new_events.append(DestroyEvent(t=world.time, body_id=bid, reason="lifetime"))

        return new_events


class SplitOnHardCollision(Rule):
    """
    When a collision impulse exceeds threshold, split each involved body
    into two smaller bodies (if large enough).
    """

    def __init__(self, impulse_threshold: float, min_radius: float = 8.0):
        self.impulse_threshold = impulse_threshold
        self.min_radius = min_radius

    def apply(self, world: World, events: List[BaseEvent], dt: float) -> List[BaseEvent]:
        new_events: List[BaseEvent] = []
        to_destroy: set[int] = set()
        new_bodies: List[Body] = []

        # Find eligible collisions
        for e in events:
            if not isinstance(e, CollisionEvent):
                continue
            if e.impulse < self.impulse_threshold:
                continue

            ids = (e.a_id, e.b_id)
            for bid in ids:
                body = world.bodies.get(bid, None)
                if body is None:
                    continue
                if body.radius <= self.min_radius:
                    continue

                # Mark for destruction & spawn two children
                to_destroy.add(body.id)
                children = self._split_body(world, body)
                new_bodies.extend(children)

        # Apply changes to world #TODO: is this correct? new bodies should be added even if no bodies are destroyed
        for b in new_bodies:
            world.add_body(b)
            new_events.append(SpawnEvent(t=world.time, body_id=b.id))
        if to_destroy:
            world.bodies = {bid: b for bid, b in world.bodies.items() if bid not in to_destroy}
            for bid in to_destroy:
                new_events.append(DestroyEvent(t=world.time, body_id=bid, reason="split"))

        return new_events

    def _split_body(self, world: World, b: Body) -> List[Body]:
        """Return two new bodies derived from b but smaller."""
        # Simple model: radius scaled, mass ~ area
        new_radius = b.radius * 0.7
        area_ratio = (new_radius ** 2) / (b.radius ** 2)  # ~ proportional to area
        new_mass = max(0.1, b.mass * area_ratio)

        children: List[Body] = []
        for _ in range(2):
            angle = random.uniform(0, 2 * np.pi)
            speed = np.linalg.norm(b.vel) * random.uniform(0.5, 1.5)
            vel = np.array([np.cos(angle), np.sin(angle)]) * speed
            offset = np.array([np.cos(angle), np.sin(angle)]) * new_radius

            c = Body(
                id=world.new_id(),
                kind=b.kind,
                pos=b.pos + offset,
                vel=vel,
                radius=new_radius,
                mass=new_mass,
                color=b.color,
                life=b.life,
                state=dict(b.state),
            )
            children.append(c)
        return children


class SpawnRandomBodies(Rule):
    """
    Spawns new bodies over time until max_bodies is reached.
    Good as a basic "feeder" rule.
    """

    def __init__(
        self,
        spawn_rate: float,        # bodies per second
        max_bodies: int,
        radius_range=(8.0, 20.0),
        speed_range=(0.0, 150.0),
    ):
        self.spawn_rate = spawn_rate
        self.max_bodies = max_bodies
        self.radius_range = radius_range
        self.speed_range = speed_range
        self._accum = 0.0

    def apply(self, world: World, events: List[BaseEvent], dt: float) -> List[BaseEvent]:
        new_events: List[BaseEvent] = []
        self._accum += dt * self.spawn_rate

        while self._accum >= 1.0 and len(world.bodies) < self.max_bodies:
            self._accum -= 1.0
            b = self._spawn_one(world)
            new_events.append(SpawnEvent(t=world.time, body_id=b.id))

        return new_events

    #TODO: fix for different boundary types and ensure that bodies spawn non-overlapping with other bodies
    def _spawn_one(self, world: World) -> Body:
        w, h = world.width, world.height

        radius = random.uniform(*self.radius_range)
        mass = max(1.0, radius * radius * 0.1)

        # spawn away from walls a bit
        x = random.uniform(radius, w - radius)
        y = random.uniform(radius, h - radius)

        angle = random.uniform(0, 2 * np.pi)
        speed = random.uniform(*self.speed_range)
        vel = np.array([np.cos(angle), np.sin(angle)]) * speed

        color = (
            random.randint(80, 255),
            random.randint(80, 255),
            random.randint(80, 255),
        )
        #TODO: only have circle bodies for now which should be generated using create_circle_body()
        return world.create_body(
            kind="circle",
            pos=np.array([x, y], dtype=float),
            vel=vel,
            radius=radius,
            mass=mass,
            color=color,
        )
        
#TODO: create collision spawning rule