# src/satisfying_sims/core/rules.py

from __future__ import annotations
from typing import TYPE_CHECKING
from abc import ABC, abstractmethod
from typing import List
import random
import numpy as np
if TYPE_CHECKING:
    from .world import World

from .events import (
    BaseEvent,
    CollisionEvent,
    DestroyEvent,
    SpawnEvent,
)
from .shapes import Body, create_circle_body

class Rule(ABC):
    """Base class for rules that modify the world based on events."""

    @abstractmethod
    def apply(self, world: World, events: List[BaseEvent], dt: float) -> List[BaseEvent]:
        """
        Apply rule logic to the world.

        Returns any new events generated by this rule (e.g., Spawn/Destroy).
        """
        ...

class SpawnOnCollision(Rule):
    """
    Whenever two bodies collide, spawn a new body.

    Default behavior:
      - Child inherits kind, radius, mass, color from body A.
      - Child is placed outside of both bodies, along the line of centers,
        at a distance that guarantees no overlap.
      - Child velocity is at rest in the center-of-mass frame of (A, B),
        i.e. in world coordinates it moves with v_cm.
    """

    def __init__(self, offset_margin: float = 0):
        """
        offset_margin: extra distance to keep between the child and parents'
        surfaces, in the same units as positions/radii.
        """
        self.offset_margin = offset_margin

    def apply(self, world: World, events: List[BaseEvent], dt: float) -> List[BaseEvent]:
        new_events: List[BaseEvent] = []

        for e in events:
            if not isinstance(e, CollisionEvent):
                continue

            a = world.bodies.get(e.a_id)
            b = world.bodies.get(e.b_id)
            if a is None or b is None:
                continue

            # 1) Inherit "what kind of body is this?"
            props = self._inherit_properties(world, a, b, e)
            child_radius = props["radius"]

            # 2) Choose where to put it and how it moves
            pos, vel = self._choose_pos_velocity(world, a, b, child_radius, e)

            # 3) Actually create the body in the world
            child = create_circle_body(
                pos=pos,
                vel=vel,
                radius=child_radius,
                mass=props["mass"],
                color=props["color"],
            ) if props["kind"] == "circle" else None
            if child is not None:
                world.add_body(child)

            # Optionally let subclasses tweak the created body
            self._postprocess_child(world, child, a, b, e)

            new_events.append(SpawnEvent(t=world.time, body_id=child.id))

        return new_events

    # ---------- hooks you can easily override / customize ----------

    def _inherit_properties(self, world: World, a: Body, b: Body, e: CollisionEvent) -> dict:
        """
        Decide what properties the child should inherit.
        Default: copy from body A.
        """
        return {
            "kind": getattr(a, "kind", "circle"),
            "radius": a.collider.radius,
            "mass": a.mass,
            "color": a.color,
        }

    def _choose_pos_velocity(
        self,
        world: World,
        a: Body,
        b: Body,
        child_radius: float,
        e: CollisionEvent,
    ):
        """
        Place the child on a line perpendicular to the line of centers (B->A),
        at distance L = max(r_a, r_b) + child_radius + offset_margin from the midpoint.

        Randomly choose which side of the line to spawn on.

        Child velocity = center-of-mass velocity of (A, B).
        """
        pos_a = np.asarray(a.pos, dtype=float)
        pos_b = np.asarray(b.pos, dtype=float)

        # Direction from B to A
        delta = pos_a - pos_b
        dist = float(np.linalg.norm(delta))

        if dist < 1e-8:
            # Degenerate: centers coincide, pick arbitrary axis
            direction = np.array([1.0, 0.0], dtype=float)
        else:
            direction = delta / dist

        # Midpoint between A and B
        mid = 0.5 * (pos_a + pos_b)

        # Perpendicular unit vector to 'direction'
        # If direction = (dx, dy), a perpendicular is (-dy, dx) or (dy, -dx)
        perp = np.array([-direction[1], direction[0]], dtype=float)
        perp /= float(np.linalg.norm(perp))

        r_a = a.collider.radius
        r_b = b.collider.radius
        R_max = max(r_a, r_b)

        # Distance from mid so we clear both parents:
        # ‖child_pos - mid‖ = R_max + child_radius + margin
        L = R_max + child_radius + self.offset_margin

        # Randomly choose side (+perp or -perp)
        sign = random.choice((-1.0, 1.0))
        child_pos = mid + sign * L * perp

        # Center-of-mass velocity
        vel_a = np.asarray(a.vel, dtype=float)
        vel_b = np.asarray(b.vel, dtype=float)
        m_a = a.mass
        m_b = b.mass
        m_tot = m_a + m_b

        if m_tot > 0.0:
            v_cm = (m_a * vel_a + m_b * vel_b) / m_tot
        else:
            v_cm = 0.5 * (vel_a + vel_b)

        child_vel = v_cm
        return child_pos, child_vel


    def _postprocess_child(
        self,
        world: World,
        child: Body,
        a: Body,
        b: Body,
        e: CollisionEvent,
    ) -> None:
        """
        Optional hook: tweak life/state/etc of the child after creation.
        Default: do nothing.
        """
        pass


class LifetimeDecay(Rule):
    """Decreases body.life each frame; destroys when <= 0."""

    def __init__(self, rate: float = 1.0):
        self.rate = rate

    def apply(self, world: World, events: List[BaseEvent], dt: float) -> List[BaseEvent]:
        new_events: List[BaseEvent] = []
        to_destroy: List[int] = []

        for b in world.bodies.values():
            if b.life < float("inf"):
                b.life -= self.rate * dt
                if b.life <= 0:
                    to_destroy.append(b.id)
        for bid in to_destroy:
            world.remove_body_by_id(bid)
            new_events.append(DestroyEvent(t=world.time, body_id=bid, reason="lifetime"))

        return new_events


class SplitOnHardCollision(Rule):
    """
    When a collision impulse exceeds threshold, split each involved body
    into two smaller bodies (if large enough).
    """

    def __init__(self, impulse_threshold: float, min_radius: float = 8.0):
        self.impulse_threshold = impulse_threshold
        self.min_radius = min_radius

    def apply(self, world: World, events: List[BaseEvent], dt: float) -> List[BaseEvent]:
        new_events: List[BaseEvent] = []
        to_destroy: set[int] = set()
        new_bodies: List[Body] = []

        # Find eligible collisions
        for e in events:
            if not isinstance(e, CollisionEvent):
                continue
            if e.impulse < self.impulse_threshold:
                continue

            ids = (e.a_id, e.b_id)
            for bid in ids:
                body = world.bodies.get(bid, None)
                if body is None:
                    continue
                if body.radius <= self.min_radius:
                    continue

                # Mark for destruction & spawn two children
                to_destroy.add(body.id)
                children = self._split_body(world, body)
                new_bodies.extend(children)

        # Apply changes to world #TODO: is this correct? new bodies should be added even if no bodies are destroyed
        for b in new_bodies:
            world.add_body(b)
            new_events.append(SpawnEvent(t=world.time, body_id=b.id))
        if to_destroy:
            world.bodies = {bid: b for bid, b in world.bodies.items() if bid not in to_destroy}
            for bid in to_destroy:
                new_events.append(DestroyEvent(t=world.time, body_id=bid, reason="split"))

        return new_events

    def _split_body(self, world: World, b: Body) -> List[Body]:
        """Return two new bodies derived from b but smaller."""
        # Simple model: radius scaled, mass ~ area
        new_radius = b.radius * 0.7
        area_ratio = (new_radius ** 2) / (b.radius ** 2)  # ~ proportional to area
        new_mass = max(0.1, b.mass * area_ratio)

        children: List[Body] = []
        for _ in range(2):
            angle = random.uniform(0, 2 * np.pi)
            speed = np.linalg.norm(b.vel) * random.uniform(0.5, 1.5)
            vel = np.array([np.cos(angle), np.sin(angle)]) * speed
            offset = np.array([np.cos(angle), np.sin(angle)]) * new_radius

            c = Body(
                id=world.new_id(),
                kind=b.kind,
                pos=b.pos + offset,
                vel=vel,
                radius=new_radius,
                mass=new_mass,
                color=b.color,
                life=b.life,
                state=dict(b.state),
            )
            children.append(c)
        return children


class SpawnRandomBodies(Rule):
    """
    Spawns new bodies over time until max_bodies is reached.
    Good as a basic "feeder" rule.
    """

    def __init__(
        self,
        spawn_rate: float,        # bodies per second
        max_bodies: int,
        radius_range=(8.0, 20.0),
        speed_range=(0.0, 150.0),
    ):
        self.spawn_rate = spawn_rate
        self.max_bodies = max_bodies
        self.radius_range = radius_range
        self.speed_range = speed_range
        self._accum = 0.0

    def apply(self, world: World, events: List[BaseEvent], dt: float) -> List[BaseEvent]:
        new_events: List[BaseEvent] = []
        self._accum += dt * self.spawn_rate

        while self._accum >= 1.0 and len(world.bodies) < self.max_bodies:
            self._accum -= 1.0
            b = self._spawn_one(world)
            new_events.append(SpawnEvent(t=world.time, body_id=b.id))

        return new_events

    #TODO: fix for different boundary types and ensure that bodies spawn non-overlapping with other bodies
    def _spawn_one(self, world: World) -> Body:
        w, h = world.width, world.height

        radius = random.uniform(*self.radius_range)
        mass = max(1.0, radius * radius * 0.1)

        # spawn away from walls a bit
        x = random.uniform(radius, w - radius)
        y = random.uniform(radius, h - radius)

        angle = random.uniform(0, 2 * np.pi)
        speed = random.uniform(*self.speed_range)
        vel = np.array([np.cos(angle), np.sin(angle)]) * speed

        color = (
            random.randint(80, 255),
            random.randint(80, 255),
            random.randint(80, 255),
        )
        #TODO: only have circle bodies for now which should be generated using create_circle_body()
        return world.create_body(
            kind="circle",
            pos=np.array([x, y], dtype=float),
            vel=vel,
            radius=radius,
            mass=mass,
            color=color,
        )
        
#TODO: create collision spawning rule