# src/satisfying_sims/core/rules.py

from __future__ import annotations
from abc import ABC, abstractmethod
from typing import List
import random
import numpy as np

from .world import World
from .events import (
    BaseEvent,
    CollisionEvent,
    DestroyEvent,
    SpawnEvent,
)

class Rule(ABC):
    """Base class for rules that modify the world based on events."""

    @abstractmethod
    def apply(self, world: World, events: List[BaseEvent], dt: float) -> List[BaseEvent]:
        """
        Apply rule logic to the world.

        Returns any new events generated by this rule (e.g., Spawn/Destroy).
        """
        ...


class LifetimeDecay(Rule):
    """Decreases shape.life each frame; destroys when <= 0."""

    def __init__(self, rate: float = 1.0):
        self.rate = rate

    def apply(self, world: World, events: List[BaseEvent], dt: float) -> List[BaseEvent]:
        new_events: List[BaseEvent] = []
        to_destroy: List[int] = []

        for s in world.shapes:
            if s.life < float("inf"):
                s.life -= self.rate * dt
                if s.life <= 0:
                    to_destroy.append(s.id)

        for sid in to_destroy:
            world.remove_shape_by_id(sid)
            new_events.append(DestroyEvent(t=world.time, shape_id=sid, reason="lifetime"))

        return new_events


class SplitOnHardCollision(Rule):
    """
    When a collision impulse exceeds threshold, split each involved shape
    into two smaller shapes (if large enough).
    """

    def __init__(self, impulse_threshold: float, min_radius: float = 8.0):
        self.impulse_threshold = impulse_threshold
        self.min_radius = min_radius

    def apply(self, world: World, events: List[BaseEvent], dt: float) -> List[BaseEvent]:
        new_events: List[BaseEvent] = []
        to_destroy: set[int] = set()
        new_shapes: List[Shape] = []

        # Find eligible collisions
        for e in events:
            if not isinstance(e, CollisionEvent):
                continue
            if e.impulse < self.impulse_threshold:
                continue

            ids = (e.a_id, e.b_id)
            for sid in ids:
                shape = _find_shape(world, sid)
                if shape is None:
                    continue
                if shape.radius <= self.min_radius:
                    continue

                # Mark for destruction & spawn two children
                to_destroy.add(shape.id)
                children = self._split_shape(world, shape)
                new_shapes.extend(children)

        # Apply changes to world
        if to_destroy:
            world.shapes = [s for s in world.shapes if s.id not in to_destroy]
            for s in new_shapes:
                world.add_shape(s)
                new_events.append(SpawnEvent(t=world.time, shape_id=s.id))
            for sid in to_destroy:
                new_events.append(DestroyEvent(t=world.time, shape_id=sid, reason="split"))

        return new_events

    def _split_shape(self, world: World, s: Shape) -> List[Shape]:
        """Return two new shapes derived from s but smaller."""
        # Simple model: radius scaled, mass ~ area
        new_radius = s.radius * 0.7
        area_ratio = (new_radius ** 2) / (s.radius ** 2)  # ~ proportional to area
        new_mass = max(0.1, s.mass * area_ratio)

        children: List[Shape] = []
        for _ in range(2):
            angle = random.uniform(0, 2 * np.pi)
            speed = np.linalg.norm(s.vel) * random.uniform(0.5, 1.5)
            vel = np.array([np.cos(angle), np.sin(angle)]) * speed
            offset = np.array([np.cos(angle), np.sin(angle)]) * new_radius

            c = Shape(
                id=world.new_id(),
                kind=s.kind,
                pos=s.pos + offset,
                vel=vel,
                radius=new_radius,
                mass=new_mass,
                color=s.color,
                life=s.life,
                state=dict(s.state),
            )
            children.append(c)
        return children


class SpawnRandomShapes(Rule):
    """
    Spawns new shapes over time until max_shapes is reached.
    Good as a basic "feeder" rule.
    """

    def __init__(
        self,
        spawn_rate: float,        # shapes per second
        max_shapes: int,
        radius_range=(8.0, 20.0),
        speed_range=(0.0, 150.0),
    ):
        self.spawn_rate = spawn_rate
        self.max_shapes = max_shapes
        self.radius_range = radius_range
        self.speed_range = speed_range
        self._accum = 0.0

    def apply(self, world: World, events: List[BaseEvent], dt: float) -> List[BaseEvent]:
        new_events: List[BaseEvent] = []
        self._accum += dt * self.spawn_rate

        while self._accum >= 1.0 and len(world.shapes) < self.max_shapes:
            self._accum -= 1.0
            s = self._spawn_one(world)
            new_events.append(SpawnEvent(t=world.time, shape_id=s.id))

        return new_events

    def _spawn_one(self, world: World) -> Shape:
        w, h = world.width, world.height

        radius = random.uniform(*self.radius_range)
        mass = max(1.0, radius * radius * 0.1)

        # spawn away from walls a bit
        x = random.uniform(radius, w - radius)
        y = random.uniform(radius, h - radius)

        angle = random.uniform(0, 2 * np.pi)
        speed = random.uniform(*self.speed_range)
        vel = np.array([np.cos(angle), np.sin(angle)]) * speed

        color = (
            random.randint(80, 255),
            random.randint(80, 255),
            random.randint(80, 255),
        )

        return world.create_shape(
            kind="circle",
            pos=np.array([x, y], dtype=float),
            vel=vel,
            radius=radius,
            mass=mass,
            color=color,
        )


def _find_shape(world: World, shape_id: int) -> Shape | None:
    for s in world.shapes:
        if s.id == shape_id:
            return s
    return None
