# src/satisfying_sims/core/rules.py

from __future__ import annotations
from typing import TYPE_CHECKING, Any
from abc import ABC, abstractmethod
from typing import List
from dataclasses import asdict
from collections import deque

import random
import numpy as np
from satisfying_sims.utils.event_rejection import RejectConfig, make_keep_prob_gnrl
from satisfying_sims.utils.random import rng
if TYPE_CHECKING:
    from .world import World

from .events import (
    BaseEvent,
    CollisionEvent,
    DestroyEvent,
    SpawnEvent,
)
from .shapes import Body, create_circle_body
from .physics import get_penetration
from satisfying_sims.utils.physics_utils import velocity_cm
from satisfying_sims.utils.reflection import get_path
from satisfying_sims.visual.color_sampler import ColorSampler

class Rule(ABC):
    """Base class for rules that modify the world based on events."""

    @abstractmethod
    def apply(self, world: World, events: List[BaseEvent], dt: float) -> List[BaseEvent]:
        """
        Apply rule logic to the world.

        Returns any new events generated by this rule (e.g., Spawn/Destroy).
        """
        ...

class DestroyOnCollision(Rule):
    """
    Whenever two bodies collide, spawn a new body.

    Default behavior:
      - Child inherits kind, radius, mass, color from body A.
      - Child is placed outside of both bodies, along the line of centers,
        at a distance that guarantees no overlap.
      - Child velocity is at rest in the center-of-mass frame of (A, B),
        i.e. in world coordinates it moves with v_cm.
    """

    def __init__(self, activation_triggers: List[dict] | None = None, different_only: bool = True, event_filter: dict[str, Any] | None = None):
        """
        offset_margin: extra distance to keep between the child and parents'
        surfaces, in the same units as positions/radii.
        vel_kick: additional velocity to give the spawned child, in the direction perpendicular to the line of centers.
        """

        self.different_only = different_only
        self.activation_triggers = deque(activation_triggers) if activation_triggers is not None else deque()
        self.activated = False
        self.t_last_trigger = 0.0
        self.trigger_on = None
        self.trigger_val = None
        self.event_filter = event_filter if event_filter is not None else {}
        self.update_activation(0.0)
        
    def update_activation(self, t: float):
        self.activated = not self.activated
        self.t_last_trigger = t
        next_trigger = self.activation_triggers.popleft() if self.activation_triggers else None
        self.trigger_on = next(iter(next_trigger)) if next_trigger is not None else None
        self.trigger_val = next_trigger.get(self.trigger_on, None) if next_trigger is not None else None
          
    def check_update_activation(self, t: float, n_bodies: int | None = None):
        if self.trigger_on is None:
            return
        if self.trigger_on == "elapsed_time":
            interval = self.trigger_val
            if t - self.t_last_trigger >= interval:
                self.update_activation(t)
        elif self.trigger_on == "body_count":
            assert self.activated, "body_count trigger only valid if destroying is active"
            assert n_bodies is not None, "n_bodies must be provided for body_count trigger"
            count = self.trigger_val
            if n_bodies <= count:
                self.update_activation(t)
        elif self.trigger_on == "total_time":
            target_time = self.trigger_val
            if t >= target_time:
                self.update_activation(t)
                
    
    def apply(self, world: World, events: List[BaseEvent], dt: float) -> List[BaseEvent]:
        new_events: List[BaseEvent] = []
        if not self.activated:
            return new_events
        for e in events:
            if not isinstance(e, CollisionEvent):
                continue
            for k, v in self.event_filter.items():
                if getattr(e, k, None) != v:
                    continue

            a = world.bodies.get(e.a_id)
            b = world.bodies.get(e.b_id)
            if a is None or b is None:
                continue
            filter_mismatch = False
            for k, v in self.event_filter.items():
                if getattr(e, k, None) != v:
                    filter_mismatch = True
                    break
            if filter_mismatch:
                continue
            #destroy both bodies
            world.remove_body_by_id(a.id)
            world.remove_body_by_id(b.id)

            new_events.append(DestroyEvent(t=world.time, body_id=a.id, reason="collision_destroy"))
            new_events.append(DestroyEvent(t=world.time, body_id=b.id, reason="collision_destroy"))

        return new_events


class SpawnOnCollision(Rule):
    """
    Whenever two bodies collide, spawn a new body.

    Default behavior:
      - Child inherits kind, radius, mass, color from body A.
      - Child is placed outside of both bodies, along the line of centers,
        at a distance that guarantees no overlap.
      - Child velocity is at rest in the center-of-mass frame of (A, B),
        i.e. in world coordinates it moves with v_cm.
    """

    def __init__(
        self, 
        offset_margin: float = 0, 
        vel_kick: float = 0.0, 
        activation_triggers: list[dict] | None = None, 
        event_filter: dict[str, Any] | None = None,
        reject_spec: dict[str, float] | None = None,
    ):
        """
        offset_margin: extra distance to keep between the child and parents'
        surfaces, in the same units as positions/radii.
        vel_kick: additional velocity to give the spawned child, in the direction perpendicular to the line of centers.
        """
        self.offset_margin = offset_margin
        self.vel_kick = vel_kick
        self.event_filter = event_filter or {}
        self.activation_triggers = deque(activation_triggers) if activation_triggers is not None else deque()
        self.activated = False
        self.t_last_trigger = 0.0
        self.trigger_on = None
        self.trigger_val = None
        self.update_activation(0.0)
        reject_cfg = RejectConfig(**reject_spec) if reject_spec is not None else None
        self.keep_prob_fn = make_keep_prob_gnrl(reject_cfg) if reject_cfg is not None else (lambda lam: 1.0)
    def update_activation(self, t: float):
        self.activated = not self.activated
        self.t_last_trigger = t
        next_trigger = self.activation_triggers.popleft() if self.activation_triggers else None
        self.trigger_on = next(iter(next_trigger)) if next_trigger is not None else None
        self.trigger_val = next_trigger.get(self.trigger_on, None) if next_trigger is not None else None
          
    def check_update_activation(self, t: float, n_bodies: int | None = None):
        if self.trigger_on is None:
            return
        if self.trigger_on == "elapsed_time":
            interval = self.trigger_val
            if t - self.t_last_trigger >= interval:
                self.update_activation(t)
        elif self.trigger_on == "body_count":
            assert self.activated, "body_count trigger only valid if spawning is active"
            assert n_bodies is not None, "n_bodies must be provided for body_count trigger"
            count = self.trigger_val
            if n_bodies >= count:
                self.update_activation(t)
        elif self.trigger_on == "total_time":
            target_time = self.trigger_val
            if t >= target_time:
                self.update_activation(t)
                
    
    def apply(self, world: World, events: List[BaseEvent], dt: float) -> List[BaseEvent]:
        new_events: List[BaseEvent] = []
        if not self.activated:
            return new_events
        for e in events:
            if not isinstance(e, CollisionEvent):
                continue
            
            a = world.bodies.get(e.a_id)
            b = world.bodies.get(e.b_id)
            if a is None or b is None:
                continue
            filter_mismatch = False
            for k, v in self.event_filter.items():
                if getattr(e, k, None) != v:
                    filter_mismatch = True
                    break
        
            if filter_mismatch:
                continue
            
            count = world.body_counter.get(a.theme_id, 0)
            p_accept = self.keep_prob_fn(count)
            if rng('physics').random() > p_accept:
                continue
            # 1) Inherit "what kind of body is this?"
            props = self._inherit_properties(world, a, b, e)
            child_radius = props["radius"]

            # 2) Choose where to put it and how it moves
            pos, vel = self._choose_pos_velocity(world, a, b, child_radius, e)
            if pos is None:
                # Couldn't find valid placement
                continue
            # 3) Actually create the body in the world #TODO: expand to support different kinds of bodies
            child = create_circle_body(
                pos=pos, 
                vel=vel, 
                radius=child_radius,
                mass=props["mass"],
                theme_id=props['theme_id'],
                appearance_policy=world.appearance_policies[props['theme_id']]
            ) if props["kind"] == "circle" else None
        
            if child is not None:
                try:
                    world.add_body(child)
                except ValueError as ex:
                    self._raise_spawn_error(child, e, world, ex)

            # Optionally let subclasses tweak the created body
            self._postprocess_child(world, child, a, b, e)

            new_events.append(SpawnEvent(t=world.time, child_id=child.id, child_pos=pos, reason="collision_spawn"))

        return new_events

    # ---------- hooks you can easily override / customize ----------

    def _inherit_properties(self, world: World, a: Body, b: Body, e: CollisionEvent) -> dict:
        """
        Decide what properties the child should inherit.
        Default: copy from body A.
        """
        #TODO: expand to support different kinds of bodies
        return {
            "kind": getattr(a, "kind", "circle"),
            "radius": a.collider.radius,
            "mass": a.mass,
            "color": a.color,
            "theme_id": a.theme_id
        }

    def _choose_pos_velocity(
        self,
        world: World,
        a: Body,
        b: Body,
        child_radius: float, # TODO: should be bounding radius of child collider when I expand beyond circles
        e: CollisionEvent,
        use_vcm: bool = False,
    ):
        """
        Place the child on a line perpendicular to the line of centers (B->A),
        at distance L = max(r_a, r_b) + child_radius + offset_margin from the midpoint.

        Randomly choose which side of the line to spawn on.

        Child velocity = center-of-mass velocity of (A, B).
        """
        pos_a = np.asarray(a.pos, dtype=float)
        pos_b = np.asarray(b.pos, dtype=float)

        # Direction from B to A
        delta = pos_a - pos_b
        dist = float(np.linalg.norm(delta))

        if dist < 1e-8:
            # Degenerate: centers coincide, pick arbitrary axis
            direction = np.array([1.0, 0.0], dtype=float)
        else:
            direction = delta / dist

        # Midpoint between A and B
        mid = e.pos

        # Perpendicular unit vector to 'direction'
        # If direction = (dx, dy), a perpendicular is (-dy, dx) or (dy, -dx)
        perp = np.array([-direction[1], direction[0]], dtype=float)
        perp /= float(np.linalg.norm(perp))

        r_a = a.collider.bounding_radius() # use bounding_radius to be safe with different collider types
        r_b = b.collider.bounding_radius()
        R_max = max(r_a, r_b)

        # Distance from mid so we clear both parents:
        # ‖child_pos - mid‖ = R_max + child_radius + margin
        L = R_max + child_radius + self.offset_margin

        # Randomly choose side (+perp or -perp)
        options = np.array([-1.0, 1.0])
        sign = rng("physics").choice(options, replace=False)
        perp *= sign
        child_pos = mid + L * perp
        if not self._valid_child_position(world, child_pos, child_radius, mid): #TODO: make bounding_radius when expanding beyond circles
            # Try the other side
            perp *= -1.0
            child_pos = mid + L * perp
            if not self._valid_child_position(world, child_pos, child_radius, mid):
                return None, None
        if use_vcm:
            v_cm = velocity_cm(a, b)
            child_vel = v_cm + self.vel_kick * perp
        else:
            va_perp = np.dot(a.vel, perp)
            vb_perp = np.dot(b.vel, perp)
            child_vel = (max(max(np.abs(va_perp), np.abs(vb_perp)), 0.0) + self.vel_kick) * perp
        return child_pos, child_vel

    def _valid_child_position(self, world: World, child_pos: np.ndarray, child_radius: float, collision_point: np.ndarray) -> bool:
        inbounds = world.boundary.contains(pos=child_pos, radius=child_radius)
        same_side = world.boundary.is_same_side(child_pos, collision_point)
        overlapping = False
        for b in world.bodies.values():
            penetration, _ = get_penetration(child_pos, child_radius, b.pos, b.collider.bounding_radius()) #conservative
            if penetration is not None and penetration > 0:
                overlapping = True
                break
        return same_side and inbounds and not overlapping

    def _postprocess_child(
        self,
        world: World,
        child: Body,
        a: Body,
        b: Body,
        e: CollisionEvent,
    ) -> None:
        """
        Optional hook: tweak life/state/etc of the child after creation.
        Default: do nothing.
        """
        pass
    def _raise_spawn_error(self, child, event, world, original_exc):
        """
        Build and raise a detailed debugging error message when a spawned body
        cannot be placed inside the world boundary.
        """
        # -- Event info --
        event_info = "\n".join(
            f"  {k}: {v}" for k, v in asdict(event).items()
        )

        # -- Parent bodies --
        a_id = getattr(event, "a_id", None)
        b_id = getattr(event, "b_id", None)

        body_a = world.bodies.get(a_id)
        body_b = world.bodies.get(b_id)

        if body_a is not None:
            body_a_info = "\n".join(
                f"  {k}: {v}" for k, v in asdict(body_a).items()
            )
        else:
            body_a_info = "  <missing>"

        if body_b is not None:
            body_b_info = "\n".join(
                f"  {k}: {v}" for k, v in asdict(body_b).items()
            )
        else:
            body_b_info = "  <missing>"

        # -- Child body info --
        child_info = "\n".join([
            f"  pos: {child.pos}",
            f"  vel: {child.vel}",
            f"  radius: {child.collider.bounding_radius()}",
            f"  mass: {child.mass}",
        ])

        # -- Boundary info --
        boundary = world.boundary
        boundary_info = "\n".join([
            f"  width: {boundary.width}",
            f"  height: {boundary.height}",
        ])

        # -- Build final message --
        msg = (
            "SpawnOnCollision produced an invalid child body placement.\n"
            f"Original error: {original_exc}\n\n"

            "CollisionEvent:\n"
            f"{event_info}\n\n"

            f"Body A (id={a_id}):\n{body_a_info}\n\n"
            f"Body B (id={b_id}):\n{body_b_info}\n\n"

            "Child Body:\n"
            f"{child_info}\n\n"

            "World Boundary:\n"
            f"{boundary_info}"
        )

        raise ValueError(msg) from original_exc

class LifetimeDecay(Rule):
    """Decreases body.life each frame; destroys when <= 0."""

    def __init__(self, rate: float = 1.0):
        self.rate = rate

    def apply(self, world: World, events: List[BaseEvent], dt: float) -> List[BaseEvent]:
        new_events: List[BaseEvent] = []
        to_destroy: List[int] = []

        for b in world.bodies.values():
            if b.life < float("inf"):
                b.life -= self.rate * dt
                if b.life <= 0:
                    to_destroy.append(b.id)
        for bid in to_destroy:
            world.remove_body_by_id(bid)
            new_events.append(DestroyEvent(t=world.time, body_id=bid, reason="lifetime"))

        return new_events


class SplitOnHardCollision(Rule):
    """
    When a collision impulse exceeds threshold, split each involved body
    into two smaller bodies (if large enough).
    """

    def __init__(self, impulse_threshold: float, min_radius: float = 8.0):
        self.impulse_threshold = impulse_threshold
        self.min_radius = min_radius

    def apply(self, world: World, events: List[BaseEvent], dt: float) -> List[BaseEvent]:
        new_events: List[BaseEvent] = []
        to_destroy: set[int] = set()
        new_bodies: List[Body] = []

        # Find eligible collisions
        for e in events:
            if not isinstance(e, CollisionEvent):
                continue
            if e.impulse < self.impulse_threshold:
                continue

            ids = (e.a_id, e.b_id)
            for bid in ids:
                body = world.bodies.get(bid, None)
                if body is None:
                    continue
                if body.radius <= self.min_radius:
                    continue

                # Mark for destruction & spawn two children
                to_destroy.add(body.id)
                children = self._split_body(world, body)
                new_bodies.extend(children)

        # Apply changes to world #TODO: is this correct? new bodies should be added even if no bodies are destroyed
        for b in new_bodies:
            world.add_body(b)
            new_events.append(SpawnEvent(t=world.time, body_id=b.id))
        if to_destroy:
            world.bodies = {bid: b for bid, b in world.bodies.items() if bid not in to_destroy}
            for bid in to_destroy:
                new_events.append(DestroyEvent(t=world.time, body_id=bid, reason="split"))

        return new_events

    def _split_body(self, world: World, b: Body) -> List[Body]:
        """Return two new bodies derived from b but smaller."""
        # Simple model: radius scaled, mass ~ area
        new_radius = b.radius * 0.7
        area_ratio = (new_radius ** 2) / (b.radius ** 2)  # ~ proportional to area
        new_mass = max(0.1, b.mass * area_ratio)

        children: List[Body] = []
        for _ in range(2):
            angle = random.uniform(0, 2 * np.pi)
            speed = np.linalg.norm(b.vel) * random.uniform(0.5, 1.5)
            vel = np.array([np.cos(angle), np.sin(angle)]) * speed
            offset = np.array([np.cos(angle), np.sin(angle)]) * new_radius

            c = Body(
                id=world.new_id(),
                kind=b.kind,
                pos=b.pos + offset,
                vel=vel,
                radius=new_radius,
                mass=new_mass,
                color=b.color,
                life=b.life,
                state=dict(b.state),
            )
            children.append(c)
        return children


class SpawnRandomBodies(Rule):
    """
    Spawns new bodies over time until max_bodies is reached.
    Good as a basic "feeder" rule.
    """

    def __init__(
        self,
        spawn_rate: float,        # bodies per second
        max_bodies: int,
        radius_range=(8.0, 20.0),
        speed_range=(0.0, 150.0),
    ):
        self.spawn_rate = spawn_rate
        self.max_bodies = max_bodies
        self.radius_range = radius_range
        self.speed_range = speed_range
        self._accum = 0.0

    def apply(self, world: World, events: List[BaseEvent], dt: float) -> List[BaseEvent]:
        new_events: List[BaseEvent] = []
        self._accum += dt * self.spawn_rate

        while self._accum >= 1.0 and len(world.bodies) < self.max_bodies:
            self._accum -= 1.0
            b = self._spawn_one(world)
            new_events.append(SpawnEvent(t=world.time, body_id=b.id))

        return new_events

    #TODO: fix for different boundary types and ensure that bodies spawn non-overlapping with other bodies
    def _spawn_one(self, world: World) -> Body:
        w, h = world.width, world.height

        radius = random.uniform(*self.radius_range)
        mass = max(1.0, radius * radius * 0.1)

        # spawn away from walls a bit
        x = random.uniform(radius, w - radius)
        y = random.uniform(radius, h - radius)

        angle = random.uniform(0, 2 * np.pi)
        speed = random.uniform(*self.speed_range)
        vel = np.array([np.cos(angle), np.sin(angle)]) * speed

        color = (
            random.randint(80, 255),
            random.randint(80, 255),
            random.randint(80, 255),
        )
        #TODO: only have circle bodies for now which should be generated using create_circle_body()
        return world.create_body(
            kind="circle",
            pos=np.array([x, y], dtype=float),
            vel=vel,
            radius=radius,
            mass=mass,
            color=color,
        )
        
#TODO: create collision spawning rule