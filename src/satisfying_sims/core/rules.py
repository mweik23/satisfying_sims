# src/satisfying_sims/core/rules.py

from __future__ import annotations
from abc import ABC, abstractmethod
from typing import List
import random
import numpy as np

from .world import World
from .events import (
    BaseEvent,
    CollisionEvent,
    DestroyEvent,
    SpawnEvent,
)
from .shapes import Body

class Rule(ABC):
    """Base class for rules that modify the world based on events."""

    @abstractmethod
    def apply(self, world: World, events: List[BaseEvent], dt: float) -> List[BaseEvent]:
        """
        Apply rule logic to the world.

        Returns any new events generated by this rule (e.g., Spawn/Destroy).
        """
        ...


class LifetimeDecay(Rule):
    """Decreases body.life each frame; destroys when <= 0."""

    def __init__(self, rate: float = 1.0):
        self.rate = rate

    def apply(self, world: World, events: List[BaseEvent], dt: float) -> List[BaseEvent]:
        new_events: List[BaseEvent] = []
        to_destroy: List[int] = []

        for b in world.bodies.values():
            if b.life < float("inf"):
                b.life -= self.rate * dt
                if b.life <= 0:
                    to_destroy.append(b.id)
        for bid in to_destroy:
            world.remove_body_by_id(bid)
            new_events.append(DestroyEvent(t=world.time, body_id=bid, reason="lifetime"))

        return new_events


class SplitOnHardCollision(Rule):
    """
    When a collision impulse exceeds threshold, split each involved body
    into two smaller bodies (if large enough).
    """

    def __init__(self, impulse_threshold: float, min_radius: float = 8.0):
        self.impulse_threshold = impulse_threshold
        self.min_radius = min_radius

    def apply(self, world: World, events: List[BaseEvent], dt: float) -> List[BaseEvent]:
        new_events: List[BaseEvent] = []
        to_destroy: set[int] = set()
        new_bodies: List[Body] = []

        # Find eligible collisions
        for e in events:
            if not isinstance(e, CollisionEvent):
                continue
            if e.impulse < self.impulse_threshold:
                continue

            ids = (e.a_id, e.b_id)
            for bid in ids:
                body = world.bodies.get(bid, None)
                if body is None:
                    continue
                if body.radius <= self.min_radius:
                    continue

                # Mark for destruction & spawn two children
                to_destroy.add(body.id)
                children = self._split_body(world, body)
                new_bodies.extend(children)

        # Apply changes to world #TODO: is this correct? new bodies should be added even if no bodies are destroyed?
        if to_destroy:
            world.bodies = {bid: b for bid, b in world.bodies.items() if bid not in to_destroy}
            for b in new_bodies:
                world.add_body(b)
                new_events.append(SpawnEvent(t=world.time, body_id=b.id))
            for bid in to_destroy:
                new_events.append(DestroyEvent(t=world.time, body_id=bid, reason="split"))

        return new_events

    def _split_body(self, world: World, b: Body) -> List[Body]:
        """Return two new bodies derived from b but smaller."""
        # Simple model: radius scaled, mass ~ area
        new_radius = b.radius * 0.7
        area_ratio = (new_radius ** 2) / (b.radius ** 2)  # ~ proportional to area
        new_mass = max(0.1, b.mass * area_ratio)

        children: List[Body] = []
        for _ in range(2):
            angle = random.uniform(0, 2 * np.pi)
            speed = np.linalg.norm(b.vel) * random.uniform(0.5, 1.5)
            vel = np.array([np.cos(angle), np.sin(angle)]) * speed
            offset = np.array([np.cos(angle), np.sin(angle)]) * new_radius

            c = Body(
                id=world.new_id(),
                kind=b.kind,
                pos=b.pos + offset,
                vel=vel,
                radius=new_radius,
                mass=new_mass,
                color=b.color,
                life=b.life,
                state=dict(b.state),
            )
            children.append(c)
        return children


class SpawnRandomBodies(Rule):
    """
    Spawns new bodies over time until max_bodies is reached.
    Good as a basic "feeder" rule.
    """

    def __init__(
        self,
        spawn_rate: float,        # bodies per second
        max_bodies: int,
        radius_range=(8.0, 20.0),
        speed_range=(0.0, 150.0),
    ):
        self.spawn_rate = spawn_rate
        self.max_bodies = max_bodies
        self.radius_range = radius_range
        self.speed_range = speed_range
        self._accum = 0.0

    def apply(self, world: World, events: List[BaseEvent], dt: float) -> List[BaseEvent]:
        new_events: List[BaseEvent] = []
        self._accum += dt * self.spawn_rate

        while self._accum >= 1.0 and len(world.bodies) < self.max_bodies:
            self._accum -= 1.0
            s = self._spawn_one(world)
            new_events.append(SpawnEvent(t=world.time, body_id=s.id))

        return new_events

    #TODO: fix for different boundary types and ensure that bodies spawn non-overlapping with other bodies
    def _spawn_one(self, world: World) -> Body:
        w, h = world.width, world.height

        radius = random.uniform(*self.radius_range)
        mass = max(1.0, radius * radius * 0.1)

        # spawn away from walls a bit
        x = random.uniform(radius, w - radius)
        y = random.uniform(radius, h - radius)

        angle = random.uniform(0, 2 * np.pi)
        speed = random.uniform(*self.speed_range)
        vel = np.array([np.cos(angle), np.sin(angle)]) * speed

        color = (
            random.randint(80, 255),
            random.randint(80, 255),
            random.randint(80, 255),
        )
        #TODO: only have circle bodies for now which should be generated using create_circle_body()
        return world.create_body(
            kind="circle",
            pos=np.array([x, y], dtype=float),
            vel=vel,
            radius=radius,
            mass=mass,
            color=color,
        )
        
#TODO: create collision spawning rule